<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>V's Blog</title><link>https://blog.witter.top</link><description>Blog description</description><copyright>V's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://img.witter.top/file/b037878209903b7d5bb17.jpg</url><title>avatar</title><link>https://blog.witter.top</link></image><lastBuildDate>Thu, 20 Jun 2024 07:22:38 +0000</lastBuildDate><managingEditor>V's Blog</managingEditor><ttl>60</ttl><webMaster>V's Blog</webMaster><item><title>CloudFlare搭建Docker镜像源</title><link>https://blog.witter.top/post/CloudFlare-da-jian-Docker-jing-xiang-yuan.html</link><description>&gt; [示例网站](https://docker.3mz.cloudns.ch/) 使用的 [教程](https://blog.lty520.faith/%E5%8D%9A%E6%96%87/%E8%87%AA%E5%BB%BAdocker-hub%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F) 和 [仓库](https://github.com/Doublemine/container-registry-worker)，对仓库代码进行了部分自定义修改&#13;
&#13;
`docker.ts`&#13;
&#13;
```typescript&#13;
import HTML from './docker.html';&#13;
&#13;
export default {&#13;
  async fetch(request: Request): Promise&lt;Response&gt; {&#13;
    const url = new URL(request.url);&#13;
    const path = url.pathname;&#13;
    const originalHost = request.headers.get('host');&#13;
    const registryHost = 'registry-1.docker.io';&#13;
&#13;
    if (path.startsWith('/v2/')) {&#13;
      const headers = new Headers(request.headers);&#13;
      headers.set('host', registryHost);&#13;
&#13;
      const registryUrl = `https://${registryHost}${path}`;&#13;
      const registryRequest = new Request(registryUrl, {&#13;
        method: request.method,&#13;
        headers: headers,&#13;
        body: request.body,&#13;
        redirect: 'follow', // 按照教程修改了这一行&#13;
      });&#13;
&#13;
      const registryResponse = await fetch(registryRequest);&#13;
&#13;
      const responseHeaders = new Headers(registryResponse.headers);&#13;
      responseHeaders.set('access-control-allow-origin', originalHost as string);&#13;
      responseHeaders.set('access-control-allow-headers', 'Authorization');&#13;
      return new Response(registryResponse.body, {&#13;
        status: registryResponse.status,&#13;
        statusText: registryResponse.statusText,&#13;
        headers: responseHeaders,&#13;
      });&#13;
    } else {&#13;
      return new Response(HTML.replace(/{{host}}/g, originalHost as string), {&#13;
        status: 200,&#13;
        headers: {&#13;
          'content-type': 'text/html'&#13;
        }&#13;
      });&#13;
    }&#13;
  }&#13;
}&#13;
```&#13;
&#13;
## 如何部署&#13;
&#13;
```shell&#13;
# 使用wrangler&#13;
wrangler publish --config wrangler-dockerhub.toml&#13;
```&#13;
&#13;
## 如何自定义域名&#13;
&#13;
访问CloudFlare后台 -&gt; Workers和Pages -&gt; 进入需要自定义的Worker -&gt; 设置 -&gt; 触发器 -&gt; 自定义域&#13;
&#13;
![image-20240620140432250](https://img.witter.top/file/519f26de32e9f4b53cc3b.png)。</description><guid isPermaLink="true">https://blog.witter.top/post/CloudFlare-da-jian-Docker-jing-xiang-yuan.html</guid><pubDate>Thu, 20 Jun 2024 06:05:28 +0000</pubDate></item><item><title>EFK日志系统</title><link>https://blog.witter.top/post/EFK-ri-zhi-xi-tong.html</link><description>&#13;
**注：现在新版本elastic stack已经支持将kafka作为输出和输入的目标**&#13;
&#13;
当日志不是结构化数据：*.log-&gt;filebeat-&gt;kafka-&gt;logstash-&gt;elasticsearch&#13;
&#13;
当日志是结构化数据：*.log-&gt;filebeat-&gt;kafka-&gt;filebeat-&gt;elasticsearch&#13;
&#13;
区别在于是否需要logstash进行日志的过滤和结构化；&#13;
&#13;
## 结构化日志&#13;
&#13;
**连接示例配置文件**&#13;
&#13;
### filebeat 1&#13;
&#13;
&gt; 此filebeat实例为日志采集端，即kafka生产者，可以有多个实例进行采集&#13;
&#13;
```yaml&#13;
filebeat.inputs:&#13;
- type: filestream #新版本常用文件流输入方式&#13;
  id: my-filestream-id #每个文件流输入必须有一个唯一的 ID。</description><guid isPermaLink="true">https://blog.witter.top/post/EFK-ri-zhi-xi-tong.html</guid><pubDate>Thu, 20 Jun 2024 03:26:28 +0000</pubDate></item><item><title>Azkaban</title><link>https://blog.witter.top/post/Azkaban.html</link><description>## 1.部署&#13;
&#13;
### 1.1 Solo&#13;
&#13;
独立服务器是Azkaban的独立实例，也是最简单的开始。</description><guid isPermaLink="true">https://blog.witter.top/post/Azkaban.html</guid><pubDate>Thu, 20 Jun 2024 02:47:18 +0000</pubDate></item><item><title>Certbot 申请SSL证书</title><link>https://blog.witter.top/post/Certbot%20-shen-qing-SSL-zheng-shu.html</link><description>## 官方网址&#13;
&#13;
https://certbot.eff.org/&#13;
&#13;
## 申请SSL证书&#13;
&#13;
&gt; 指定Nginx路径方法：&#13;
&gt;&#13;
&gt; 方式1： certbot --nginx    (当linux有多个版本nginx，会出现找错nginx的配置文件路径)&#13;
&gt;&#13;
&gt; 方式2： certbot --nginx-server-root  /usr/local/nginx/conf    (指定nginx的配置文件路径)&#13;
&#13;
1. 为单域名申请SSL证书&#13;
&#13;
   ```shell&#13;
   # 安装 certbot 以及 certbot nginx 插件&#13;
   sudo yum install certbot python2-certbot-nginx -y&#13;
   &#13;
   # 执行配置，中途会询问你的邮箱，如实填写即可&#13;
   sudo certbot --nginx&#13;
   &#13;
   # 自动续约&#13;
   sudo certbot renew --dry-run&#13;
   &#13;
   # 获得并安装一个证书。</description><guid isPermaLink="true">https://blog.witter.top/post/Certbot%20-shen-qing-SSL-zheng-shu.html</guid><pubDate>Thu, 20 Jun 2024 02:44:24 +0000</pubDate></item><item><title>V's first</title><link>https://blog.witter.top/post/V%27s%20first.html</link><description>&gt; just a test。</description><guid isPermaLink="true">https://blog.witter.top/post/V%27s%20first.html</guid><pubDate>Thu, 20 Jun 2024 02:19:02 +0000</pubDate></item></channel></rss>