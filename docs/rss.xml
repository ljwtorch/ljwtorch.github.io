<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>V's Blog</title><link>https://blog.witter.top</link><description>自有清风常载鹤，从无猜意不惊鸥。</description><copyright>V's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://img.witter.top/file/b037878209903b7d5bb17.jpg</url><title>avatar</title><link>https://blog.witter.top</link></image><lastBuildDate>Thu, 20 Jun 2024 14:24:55 +0000</lastBuildDate><managingEditor>V's Blog</managingEditor><ttl>60</ttl><webMaster>V's Blog</webMaster><item><title>Kubernetes</title><link>https://blog.witter.top/post/Kubernetes.html</link><description>## 安装&#13;
&#13;
### 转发 IPv4 并让 iptables 看到桥接流量&#13;
&#13;
```shell&#13;
cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf&#13;
overlay&#13;
br_netfilter&#13;
EOF&#13;
&#13;
sudo modprobe overlay&#13;
sudo modprobe br_netfilter&#13;
&#13;
# 设置所需的 sysctl 参数，参数在重新启动后保持不变&#13;
cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf&#13;
net.bridge.bridge-nf-call-iptables  = 1&#13;
net.bridge.bridge-nf-call-ip6tables = 1&#13;
net.ipv4.ip_forward                 = 1&#13;
EOF&#13;
&#13;
# 应用 sysctl 参数而不重新启动&#13;
sudo sysctl --system&#13;
```&#13;
&#13;
通过运行以下指令确认 `br_netfilter` 和 `overlay` 模块被加载：&#13;
&#13;
```bash&#13;
lsmod | grep br_netfilter&#13;
lsmod | grep overlay&#13;
```&#13;
&#13;
通过运行以下指令确认 `net.bridge.bridge-nf-call-iptables`、`net.bridge.bridge-nf-call-ip6tables` 和 `net.ipv4.ip_forward` 系统变量在你的 `sysctl` 配置中被设置为 1：&#13;
&#13;
```bash&#13;
sysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward&#13;
```&#13;
&#13;
### 临时关闭swap分区&#13;
&#13;
```shell&#13;
sudo swapoff -a&#13;
# Debian永久关闭&#13;
systemctl --type swap --all&#13;
systemctl mask dev-xxx.swap&#13;
```&#13;
&#13;
### 配置cgroup驱动&#13;
&#13;
```shell&#13;
# 备份/etc/containerd/config.toml&#13;
containerd config default &gt; /etc/containerd/config.toml&#13;
&#13;
SystemdCgroup = true&#13;
&#13;
[plugins.'io.containerd.grpc.v1.cri']&#13;
  sandbox_image = 'registry.aliyuncs.com/google_containers/pause:3.6'&#13;
```&#13;
&#13;
### 安装 kubeadm、kubelet 和 kubectl&#13;
&#13;
```shell&#13;
# 基于Red Hat的发行版&#13;
# 将 SELinux 设置为 permissive 模式（相当于将其禁用）&#13;
sudo setenforce 0&#13;
sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config&#13;
&#13;
# 此操作会覆盖 /etc/yum.repos.d/kubernetes.repo 中现存的所有配置&#13;
cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF&#13;
[kubernetes]&#13;
name=Kubernetes&#13;
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64&#13;
enabled=1&#13;
gpgcheck=0&#13;
repo_gpgcheck=0&#13;
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg&#13;
EOF&#13;
&#13;
sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes&#13;
sudo systemctl enable --now kubelet&#13;
&#13;
# 基于Debian的发行版&#13;
sudo apt-get update&#13;
# apt-transport-https 可能是一个虚拟包（dummy package）；如果是的话，你可以跳过安装这个包&#13;
sudo apt-get install -y apt-transport-https ca-certificates curl&#13;
&#13;
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg&#13;
&#13;
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list&#13;
&#13;
sudo apt-get update&#13;
sudo apt-get install -y kubelet kubeadm kubectl&#13;
sudo apt-mark hold kubelet kubeadm kubectl&#13;
```&#13;
&#13;
### 添加指令补全&#13;
&#13;
```shell&#13;
sudo apt-get install bash-completion&#13;
echo 'source &lt;(kubectl completion bash)' &gt;&gt; ~/.bashrc&#13;
source ~/.bashrc&#13;
cat ~/.bashrc&#13;
```&#13;
&#13;
&#13;
&#13;
### 初始化Master节点&#13;
&#13;
控制平面节点是运行控制平面组件的机器， 包括 etcd（集群数据库） 和 API 服务器 （命令行工具 kubectl 与之通信）。</description><guid isPermaLink="true">https://blog.witter.top/post/Kubernetes.html</guid><pubDate>Thu, 20 Jun 2024 14:19:12 +0000</pubDate></item><item><title>Linux 工具</title><link>https://blog.witter.top/post/Linux%20-gong-ju.html</link><description># Linux工具&#13;
&#13;
## psmisc&#13;
&#13;
psmisc 是一个 Linux 工具集，它提供了一些管理和监视进程的实用工具。</description><guid isPermaLink="true">https://blog.witter.top/post/Linux%20-gong-ju.html</guid><pubDate>Thu, 20 Jun 2024 13:51:19 +0000</pubDate></item><item><title>Helm</title><link>https://blog.witter.top/post/Helm.html</link><description>[官方文档](https://helm.sh/zh/docs/intro/install/)&#13;
&#13;
### 用二进制版本安装&#13;
&#13;
每个Helm [[版本](https://github.com/helm/helm/releases)](https://github.com/helm/helm/releases)都提供了各种操作系统的二进制版本，这些版本可以手动下载和安装。</description><guid isPermaLink="true">https://blog.witter.top/post/Helm.html</guid><pubDate>Thu, 20 Jun 2024 13:36:36 +0000</pubDate></item><item><title>Hadoop</title><link>https://blog.witter.top/post/Hadoop.html</link><description>&#13;
## 1.Hadoop概述&#13;
&#13;
**核心组件**&#13;
&#13;
**HDFS**（分布式文件系统）：解决海量数据存储&#13;
&#13;
**YARN**（作业调度和集群资源管理的框架）：解决资源任务调度&#13;
&#13;
**MAPREDUCE**（分布式运算编程框架）：解决海量数据计算&#13;
&#13;
**其他框架**&#13;
&#13;
| **框架**  | **用途**                                                  |&#13;
| --------- | --------------------------------------------------------- |&#13;
| HDFS      | 分布式文件系统                                            |&#13;
| MapReduce | 分布式运算程序开发框架                                    |&#13;
| ZooKeeper | 分布式协调服务基础组件                                    |&#13;
| HIVE      | 基于HADOOP的分布式数据仓库，提供基于SQL的查询数据操作     |&#13;
| FLUME     | 日志数据采集框架                                          |&#13;
| oozie     | 工作流调度框架                                            |&#13;
| Sqoop     | 数据导入导出工具（比如用于mysql和HDFS之间）               |&#13;
| Impala    | 基于hive的实时sql查询分析                                 |&#13;
| Mahout    | 基于mapreduce/spark/flink等分布式运算框架的机器学习算法库 |&#13;
&#13;
**默认端口更改**&#13;
&#13;
1. 在hadoop3.x之前，多个Hadoop服务的默认端口都属于Linux的临时端口范围（32768-61000）。</description><guid isPermaLink="true">https://blog.witter.top/post/Hadoop.html</guid><pubDate>Thu, 20 Jun 2024 13:35:27 +0000</pubDate></item><item><title>CloudFlare搭建Docker镜像源</title><link>https://blog.witter.top/post/CloudFlare-da-jian-Docker-jing-xiang-yuan.html</link><description>&gt; [示例网站](https://docker.3mz.cloudns.ch/) 使用的 [教程](https://blog.lty520.faith/%E5%8D%9A%E6%96%87/%E8%87%AA%E5%BB%BAdocker-hub%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F) 和 [仓库](https://github.com/Doublemine/container-registry-worker)，对仓库代码进行了部分自定义修改&#13;
&#13;
`docker.ts`&#13;
&#13;
```typescript&#13;
import HTML from './docker.html';&#13;
&#13;
export default {&#13;
  async fetch(request: Request): Promise&lt;Response&gt; {&#13;
    const url = new URL(request.url);&#13;
    const path = url.pathname;&#13;
    const originalHost = request.headers.get('host');&#13;
    const registryHost = 'registry-1.docker.io';&#13;
&#13;
    if (path.startsWith('/v2/')) {&#13;
      const headers = new Headers(request.headers);&#13;
      headers.set('host', registryHost);&#13;
&#13;
      const registryUrl = `https://${registryHost}${path}`;&#13;
      const registryRequest = new Request(registryUrl, {&#13;
        method: request.method,&#13;
        headers: headers,&#13;
        body: request.body,&#13;
        redirect: 'follow', // 按照教程修改了这一行&#13;
      });&#13;
&#13;
      const registryResponse = await fetch(registryRequest);&#13;
&#13;
      const responseHeaders = new Headers(registryResponse.headers);&#13;
      responseHeaders.set('access-control-allow-origin', originalHost as string);&#13;
      responseHeaders.set('access-control-allow-headers', 'Authorization');&#13;
      return new Response(registryResponse.body, {&#13;
        status: registryResponse.status,&#13;
        statusText: registryResponse.statusText,&#13;
        headers: responseHeaders,&#13;
      });&#13;
    } else {&#13;
      return new Response(HTML.replace(/{{host}}/g, originalHost as string), {&#13;
        status: 200,&#13;
        headers: {&#13;
          'content-type': 'text/html'&#13;
        }&#13;
      });&#13;
    }&#13;
  }&#13;
}&#13;
```&#13;
&#13;
## 如何部署&#13;
&#13;
```shell&#13;
# 使用wrangler&#13;
wrangler publish --config wrangler-dockerhub.toml&#13;
```&#13;
&#13;
## 如何自定义域名&#13;
&#13;
访问CloudFlare后台 -&gt; Workers和Pages -&gt; 进入需要自定义的Worker -&gt; 设置 -&gt; 触发器 -&gt; 自定义域&#13;
&#13;
![image-20240620140432250](https://img.witter.top/file/519f26de32e9f4b53cc3b.png)。</description><guid isPermaLink="true">https://blog.witter.top/post/CloudFlare-da-jian-Docker-jing-xiang-yuan.html</guid><pubDate>Thu, 20 Jun 2024 06:05:28 +0000</pubDate></item><item><title>EFK日志系统</title><link>https://blog.witter.top/post/EFK-ri-zhi-xi-tong.html</link><description>&#13;
**注：现在新版本elastic stack已经支持将kafka作为输出和输入的目标**&#13;
&#13;
当日志不是结构化数据：*.log-&gt;filebeat-&gt;kafka-&gt;logstash-&gt;elasticsearch&#13;
&#13;
当日志是结构化数据：*.log-&gt;filebeat-&gt;kafka-&gt;filebeat-&gt;elasticsearch&#13;
&#13;
区别在于是否需要logstash进行日志的过滤和结构化；&#13;
&#13;
## 结构化日志&#13;
&#13;
**连接示例配置文件**&#13;
&#13;
### filebeat 1&#13;
&#13;
&gt; 此filebeat实例为日志采集端，即kafka生产者，可以有多个实例进行采集&#13;
&#13;
```yaml&#13;
filebeat.inputs:&#13;
- type: filestream #新版本常用文件流输入方式&#13;
  id: my-filestream-id #每个文件流输入必须有一个唯一的 ID。</description><guid isPermaLink="true">https://blog.witter.top/post/EFK-ri-zhi-xi-tong.html</guid><pubDate>Thu, 20 Jun 2024 03:26:28 +0000</pubDate></item><item><title>Azkaban</title><link>https://blog.witter.top/post/Azkaban.html</link><description>## 1.部署&#13;
&#13;
### 1.1 Solo&#13;
&#13;
独立服务器是Azkaban的独立实例，也是最简单的开始。</description><guid isPermaLink="true">https://blog.witter.top/post/Azkaban.html</guid><pubDate>Thu, 20 Jun 2024 02:47:18 +0000</pubDate></item><item><title>Certbot 申请SSL证书</title><link>https://blog.witter.top/post/Certbot%20-shen-qing-SSL-zheng-shu.html</link><description>## 官方网址&#13;
&#13;
https://certbot.eff.org/&#13;
&#13;
## 申请SSL证书&#13;
&#13;
&gt; 指定Nginx路径方法：&#13;
&gt;&#13;
&gt; 方式1： certbot --nginx    (当linux有多个版本nginx，会出现找错nginx的配置文件路径)&#13;
&gt;&#13;
&gt; 方式2： certbot --nginx-server-root  /usr/local/nginx/conf    (指定nginx的配置文件路径)&#13;
&#13;
1. 为单域名申请SSL证书&#13;
&#13;
   ```shell&#13;
   # 安装 certbot 以及 certbot nginx 插件&#13;
   sudo yum install certbot python2-certbot-nginx -y&#13;
   &#13;
   # 执行配置，中途会询问你的邮箱，如实填写即可&#13;
   sudo certbot --nginx&#13;
   &#13;
   # 自动续约&#13;
   sudo certbot renew --dry-run&#13;
   &#13;
   # 获得并安装一个证书。</description><guid isPermaLink="true">https://blog.witter.top/post/Certbot%20-shen-qing-SSL-zheng-shu.html</guid><pubDate>Thu, 20 Jun 2024 02:44:24 +0000</pubDate></item><item><title>V's first</title><link>https://blog.witter.top/post/V%27s%20first.html</link><description>&gt; just a test。</description><guid isPermaLink="true">https://blog.witter.top/post/V%27s%20first.html</guid><pubDate>Thu, 20 Jun 2024 02:19:02 +0000</pubDate></item></channel></rss>